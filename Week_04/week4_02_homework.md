**题目：**

1、列举常用的并发操作API和工具类，简单分析其使用场景和优缺点。

**答题如下：**


| API和工具类 | 使用场景 | 优点 | 缺点 |
|  ----  | ----  |----  |----  |
| Lock/Condition | 互斥访问 |1.能够响应中断；2.支持超时；3.非阻塞获取锁 |显示加锁和解锁 |
| LockSupport | 阻塞线程 | 易用 |显示阻塞和释放 |
| AtomicXxx原子类 | 计数器 | 无锁                                       |场景有限 |
| Semaphore | 同一时间控制并发线程数 |等待时不浪费CPU时间 |使用需要谨慎，执行顺序不恰当就容易死锁 |
| CountdownLatch | Master 线程等待 Worker 线程把任务执行完 |可以聚合多线程执行 |不可重复利用；场景单一 |
| CyclicBarrier | 任务执行到一定阶段, 等待其他任务对齐。 |可以聚合多线程执行；可重复利用 |场景单一 |
| Future | 获取线程的执行结果 |可以获取线程执行结果 |只适用单线程 |
| FutureTask | 获取线程的执行结果 |可以获取线程执行结果 |只适用单线程 |
| CompletableFuture | 异步回调执行结果 |可以组合多种操作 |需要一定函数编程基础 |
| ReadWriteLock | 读多写少 |读多写少场景性能较高 |1.写比较频繁的场景不适合；2.读时不允许写操作 |
| StampedLock | 读多写少 |读时允许写操作（ReadWriteLock的优化） |写比较频繁的场景不适合 |
| CopyOnWriteArrayList | 并发使用集合list |提供线程安全的List集合 | 写时会有两份对象；无法实时一致性             |
| ConcurrentHashMap | 并发使用集合map |提供线程安全的HashMap集合 |--- |




**题目：**

2、请思考：什么是并发？什么是高并发？实现高并发高可用系统需要考虑哪些因素，对于这些你是怎么理解的？

**答题如下：**

并发（concurrent），指多个线程在共同完成一件事情; 互相之间有依赖/有状态，例如多个部门做同一个系统。

高并发，指系统能够同时并行处理很多请求。 高并发相关常用的一些指标有响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数等。

- **响应时间**：系统对请求做出响应的时间。
- **吞吐量**：单位时间内处理的请求数量。
- **QPS**：每秒响应请求数。
- **并发用户数**：同时承载正常使用系统功能的用户数量。

高并发系统需要考虑：

- **应用层优化：**处理网站业务的服务器。使用缓存，异步，集群。
- **代码优化：**合理的架构，多线程，资源复用（对象池，线程池等），良好的数据结构，JVM调优，单例，Cache 等。
- **存储优化：**缓存、固态硬盘、光纤传输、优化读写、磁盘冗余、分布式存储（HDFS）、NoSQL 等。

高可用系统需要考虑：

- **应用层：**一般设计为无状态的，对于每次请求，使用哪一台服务器处理是没有影响的。一般使用负载均衡技术（需要解决 Session 同步问题）实现高可用。
- **服务层：**负载均衡，分级管理，快速失败（超时设置），异步调用，服务降级，幂等设计等。
- **数据层：**冗余备份（冷，热备[同步，异步]，温备），失效转移（确认，转移，恢复）。数据高可用方面著名的理论基础是 CAP 理论。（持久性，可用性，数据一致性[强一致，用户一致，最终一致]） 

个人理解：

高并发高可用系统的设计，首先要量化自己系统目前指标或者即将要设计的系统指标，即当前系统响应时间，吞吐量，QPS，TPS，并发数的极限值，根据业务场景判断，系统需要达到的极限值，有一个量化指标，方便后续优化和测试是否达标的重要参考值；其次，这类设计和优化，从核心的重要的模块开始做，比全面所有模块做优化更实际；接着，如果通过增加缓存，更换磁盘，JVM调优这类不需要大动干戈的修改就能实现要求，那么尽量不去整改整个系统；最后才是代码优化。




**题目：**

3、请思考：还有哪些跟并发类似/有关的场景和问题，有哪些可以借鉴的解决办法。

**答题如下：**

类似场景：数据库事务，分布式锁

数据库事务具有ACID特性，即原子性、一致性、隔离性、持久性。其中原子性，隔离性和并发类似，原子性要求操作要么全完成，要么不执行，在并发中同样要求某个共享变量被线程操作，不能被其他线程插入，由该线程操作完，才能让其他线程接着操作；隔离性要求多个并发事务之间相互隔离，也就是操作同一张表，要求互不影响，在并发中，并发读写也有类似，隔离性使用的共享锁，排他锁有点类似并发的读写锁，可以并发读，但读写互斥。

数据库表中有个乐观锁解决并发问题，借助新增version字段，每次更新时不加锁，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据，重新获取更新。

分布式锁的要求与单机情况下并发锁类似，唯一区别大概是它的并发来自多个节点，单一某个节点的锁是锁不住其他节点的请求，实现分布式锁最简单的处理方式，让所有节点请求锁时，去同一个位置获取，让锁集中分配，比如redis的解决方案。分布式情况下使用的方案，单机情况也是可以的。




**题目：**

4、把多线程和并发相关知识带你梳理一遍，画一个脑图，截图上传到github上。

**答题如下：**



**参考：**

[java进阶训练营](https://u.geekbang.org/subject/java/1000579?utm_source=u_list_web&utm_medium=u_list_web&utm_term=u_list_web)

[并发容器之CopyOnWriteArrayList](https://juejin.im/post/6844903602436374541#heading-5)

[Semaphores in Operating System](https://www.tutorialspoint.com/semaphores-in-operating-system)

[程序员们的三高：高并发、高性能、高可用](https://juejin.im/post/6844903944955625479)

[构建一个高性能、高可用的大型分布式网站](https://www.cnblogs.com/guixia621/p/9245596.html)
