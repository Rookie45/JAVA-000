学习笔记



# 为什么要做数据库拆分

传统的将数据集中存储至单一数据节点的解决方案，在容量、性能、可用性和运维成本这三方面已经难于满足互联网的海量数据场景。在单库单表数据量超过一定容量水位的情况下，索引树层级增加，磁盘 IO 也很可能出现压力，会导致很多问题，比如查询缓慢，DDL操作影响变得巨大，数据备份和恢复的时间成本随着数据量的大小而愈发不可控。

**主从结构解决了高可用，读扩展，但是单机容量不变，单机写性能无法解决。**

那么从数据量大方面思考，提升单机容量有限，但如果将数据分摊到多机多库，那么机器的个数就是容量的上限，这样量大的问题就可以解决了，那么这种形式就是数据库拆分，**通过将数据摊到（不同机器）多个库上，降低单个节点的数据压力，从而达到整个系统的数据容量的提升。**

业界有总结拆分扩展的类型，可以从三个维度来看：

- 通过单个系统复制，以集群形式扩展
- 通过解耦业务模块，以多个业务中心进行拆分扩展
- 通过拆分不同数据扩展，以数据分片进行扩展



# BASE柔性事务

### 本地事务，XA(2PC)以及BASE对比

|              | 本地事务         | 两(三)阶段事务 | 柔性事务       |
| ------------ | ---------------- | -------------- | -------------- |
| 业务改造     | 无               | 无             | 实现相关接口   |
| (全局)一致性 | 不支持           | 支持           | 最终一致       |
| (全局)隔离性 | 不支持           | 支持           | 业务方保证     |
| 并发性能     | 无影响           | 严重衰退       | 略微衰退       |
| 适合场景     | 业务方处理不一致 | 短事务和低并发 | 长事务和高并发 |

### BASE柔性事务常见模式

- TCC

   通过手动补偿处理
   
   TCC模式即将每个业务服务操作分为两阶段，第一个阶段检查并预留相关资源，第二个阶段业务服务的Try状态来操作，如果都成功，则进行Confirm操作，如果任意一个Try发生错误，则全部Cancel。
   
   TCC的使用要求业务接口必须实现三段逻辑：
   
   1. 准备操作Try：完成所有业务检查，预留相关资源。
   2. 确认操作Confirm：真正执行的业务逻辑，不做任何业务检查，只使用Try阶段预留的业务资源。因此，只要Try操作成功，Confirm必须能成功，另外，Confirm操作需满足幂等性，保证一笔分布式事务有且仅成功一次。（如果Confirm失败，可以选择一直重试，也可以选择重试多次后进行回滚）
   3. 取消操作Cancel：释放Try阶段预留的业务资源（也有回滚try操作）。同样的，Cancel操作也需要满足幂等性。
   
   存在的问题：
   
   1. 空回滚：try和cancel和java中的try和finally有点像，在try出现问题时，cancel被执行，如果try中对数据库的操作压根没执行，那cancel执行了个寂寞，这就是空回滚。所以需要在cancel中判断try中数据库操作是否真被执行。
   2. 悬挂问题：TCC的三段逻辑是拆分开的，那么存在Try和Cancel有先后问题，如果某次TCC，Cancel比Try先到，那后到的Try预留的资源，没有地方可以释放了。所以在Cacnel执行时，留下执行痕迹，在后来的Try到来时，先检查与自己匹配的Cancel是否先执行了，如果执行了，那就不Try了。
   3. 幂等问题：Confirm阶段反复重试，可能数据库里某次Confirm执行成功了，但Confirm阶段不知道，又重试了，这里就需要支持去重。
   
   总结：TCC相当于将原本的一个大事务，拆分成几个小事务，减小了事务规模，也就增加了并发能力。

- AT

   通过自动补偿处理
   
   1. 一阶段
   
      有点像XA，这个阶段执行事务的SQL，并插入一个SQL解析引擎，将本次执行的SQL的影响数据，记录下来执行前的现场情况
   
   2. 二阶段
   
      生成提交的SQL的reverse SQL，用于回滚一阶段执行的SQL影响。
      
### 扩展知识

**zookeeper参数说明**

- tickTime: ZooKeeper 中使用的基本时间单元, 以毫秒为单位, 默认值是 2000。它用来调节心跳和超时。例如, 默认的会话超时时间是两倍的 tickTime。

- initLimit: 默认值是 10, 即 tickTime 属性值的 10 倍。它用于配置允许 followers 连接并同步到 leader 的最大时间。如果 ZooKeeper 管理的数据量很大的话可以增加这个值。

- syncLimit: 默认值是 5, 即 tickTime 属性值的 5 倍。它用于配置leader 和 followers 间进行心跳检测的最大延迟时间。如果在设置的时间内 followers 无法与 leader 进行通信, 那么 followers 将会被丢弃。

- dataDir: ZooKeeper 用来存储内存数据库快照的目录, 并且除非指定其它目录, 否则数据库更新的事务日志也将会存储在该目录下。建议配置 dataLogDir 参数来指定 ZooKeeper 事务日志的存储目录。

- clientPort: 服务器监听客户端连接的端口, 也即客户端尝试连接的端口, 默认值是 2181。

- maxClientCnxns: 在 socket 级别限制单个客户端与单台服务器之前的并发连接数量, 可以通过 IP 地址来区分不同的客户端。它用来防止某种类型的 DoS 攻击, 包括文件描述符耗尽。默认值是 60。将其设置为 0 将完全移除并发连接数的限制。

- autopurge.snapRetainCount: 配置 ZooKeeper 在自动清理的时候需要保留的数据文件快照的数量和对应的事务日志文件, 默认值是 3。

- autopurge.purgeInterval: 和参数 autopurge.snapRetainCount 配套使用, 用于配置 ZooKeeper 自动清理文件的频率, 默认值是 1, 即默认开启自动清理功能, 设置为 0 则表示禁用自动清理功能。



**参考**

[Java进阶训练营]()
