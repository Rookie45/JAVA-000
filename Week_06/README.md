学习笔记

学习笔记



# 面向对象设计原则

### S.O.L.I.D

它是面向对象设计和编程(OOD&OOP)中几个重要编码原则(Programming Priciple)的首字母缩写。

1. **S**RP: The Single Responsibility Principle 单一责任原则

2. **O**CP: The Open Closed Principle 开放封闭原则
3. **L**SP: The Liskov Substitution Principle 里氏替换原则
4. **I**SP: The Interface Segregation Principle 接口分离原则
5. **D**IP: The Dependency Inversion Principle 依赖倒置原则

#### 单一责任原则

让一个类只完成一个功能，如果承担过多工作，那么应该分解这个类。

比如订单信息与邮寄地址，应该用两个类处理，再比如一个函数兼顾加减乘除，那么应该拆分成四个函数，每个函数完成单一的功能，这样组合起来也方便。

#### 开放封闭原则

实体类应该对扩展开放，对修改封闭。

比如，商店打折，如果写成一个类，一个函数if{}else if{}...这样判断处理，那么每新增一个打折方式，就得修改这个类里的函数，这是一种有风险的操作。更合适的处理，是采用策略模式，给每种折扣一个类，实现统一的接口，接口里仅打折这样一个功能，那么新增的打折方式，只要新增类即可，不用修改现有类。

#### 里氏替换原则

一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序的错误。

如果两个类有些继承关系，但不完全是，那么可以采用委派模式，也可以采用聚合关系，将A作为B的某个属性

#### 接口分离原则

客户(client)不应被强迫依赖它不使用的方法。即，一个类实现的接口中，包含了它不需要的方法。将接口拆分成更小和更具体的接口，有助于解耦，从而更容易重构、更改。

比如，商家接入移动支付API的场景举例，支付宝支持收费和退费；微信接口只支持收费。如果接口设计了收费和退费，那么微信支付就有一个空实现，而改进的话，将一个接口拆成两个接口，收费一个，退费一个。

#### 依赖倒置原则

1. 高层次的模块不应依赖低层次的模块，他们都应该依赖于抽象。
2. 抽象不应依赖于具体实现，具体实现应依赖抽象。

> **扩展**
>
> 控制反转(IOC)和依赖注入(DI)是Spring中最重要的核心概念之一，而两者实际上是一体两面的。
>
> - 依赖注入
>   - 一个类依赖另一个类的功能，那么就通过注入，如构造器、setter方法等，将这个类的实例引入。
>   - 侧重于实现。
> - 控制反转
>   - 创建实例的控制权由一个实例的代码剥离到IOC容器控制，如xml配置中。
>   - 侧重于原理。
>   - 反转了什么：原先是由类本身去创建另一个类，控制反转后变成了被动等待这个类的注入。



### 最小知识原则

最少知识原则(LKP)说的是一个软件实体应当尽可能少地与其他实体发生相互作用。

如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些请求。

> **扩展**
>
> 设计模式里，中介者和外观模式都体现了这一原则

### KISS

保持简单和单调（Keep It Simple, Stupid）,表达的是代码简单、清晰、易于理解。

KISS思想类似单一职责，复杂的问题通过拆分成多个简单易于理解的小模块处理，而不是在一个大的复杂的模块里解决，这样不利于维护，且容易有bug。

### DRY

不要重复自己（Don't Repeat Yourself），这是软件开发的一个基本原则，目的是减少信息的重复。该原理表述:“每一个知识或逻辑必须在一个系统中有一个单一的、明确的表示。”

DRY原则的一个很好的例子是企业库enterprise libraries中的helper类，其中每行代码都在库libraries和helper类中是惟一的。

### 高内聚低耦合

高内聚低耦合，是软件工程中的概念，是判断软件设计好坏的标准，主要用于程序的面向对象的设计，主要看类的内聚性是否高，耦合度是否低。 目的是使程序模块的可重用性、移植性大大增强。 通常程序结构中各模块的内聚程度越高，模块间的耦合程度就越低。

# 设计模式



### Proxy（代理模式）

一个类代表另一个类的功能

**意图：**为其他对象提供一种代理以控制对这个对象的访问。

**主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

**何时使用：**想在访问一个类时做一些控制。

**如何解决：**增加中间层。

> **扩展**
>
> **委派模式**
>
> 委派模式的基本作用就是负责任务的调度和分配任务
>
> 与代理比较：
>
> - 委派模式的基本目的就是负责任务的调用和分配，和代理模式很像，可以看成是一个特殊的静态代理的全权代理
> - 但是代理模式注重过程()，委派模式注重结果(老板不关注任务是怎么完成的，只管把任务交给经理让他去委派调度)。
> - 代理模式中，代理类的被代理对象始终不变，而委派模式中委派类的被委托对象可以随时切换。
> - 委派模式中委派类相当于全权代理，而不是像代理模式是部分代理
> - 也有人理解为代理模式中二者是上下级关系，而委派模式中二者是平级关系



# 类与类之间的关系

### 关联关系

- **单向关联**

  Customer与Address的关系，每个顾客都有一个地址。UML图中带箭头的直线表示

- **双向关联**

  Customer与Product的关系，顾客可以购买多个商品，而通类商品可以被多个顾客购买。UML图中不带箭头的直线表示

- **自关联**

  自己包含自己，类似递归，UML类图中一个带有箭头且指向自身的直线表示

### 聚合关系

Car和Engine的关系，UML图中带空心菱形和箭头的直线表示，菱形指向Car

### 组合关系

Mouth和Head的关系，UML图中带实心菱形和箭头的直线表示，菱形指向Head

### 依赖关系

Driver的drive方法只有传入Car对象才能发挥作用，因此Driver类依赖于Car类。UML图中带有箭头的虚线表示，箭头指向依赖类。

### 继承关系

类继承另一个类，extend关键字，UML图中空心三角+实线

### 接口实现关系

类实现某个接口，implement关键字，UML图中空心三角+虚线

> **扩展**
>
> 组合和聚合的区别，组合中“部分”脱离“整体”便无法存在，聚合中“部分”脱离“整体”是可以存在的。



**参考**

[java进阶训练营](https://u.geekbang.org/subject/java/1000579?utm_source=u_list_web&utm_medium=u_list_web&utm_term=u_list_web)

[面向对象的SOLID原则白话篇](https://www.cnblogs.com/wuyuegb2312/p/7011708.html)

[设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)

[【设计模式】——代理、策略、委派模式还在傻傻分不清？](https://blog.csdn.net/qq_37141773/article/details/100561553)

[高内聚低耦合_百度百科](https://baike.baidu.com/item/高内聚低耦合)

