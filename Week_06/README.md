学习笔记



# 面向对象设计原则

### S.O.L.I.D

它是面向对象设计和编程(OOD&OOP)中几个重要编码原则(Programming Priciple)的首字母缩写。

1. **S**RP: The Single Responsibility Principle 单一责任原则
2. **O**CP: The Open Closed Principle 开放封闭原则
3. **L**SP: The Liskov Substitution Principle 里氏替换原则
4. **I**SP: The Interface Segregation Principle 接口分离原则
5. **D**IP: The Dependency Inversion Principle 依赖倒置原则

#### 单一责任原则

让一个类只完成一个功能，如果承担过多工作，那么应该分解这个类。

比如订单信息与邮寄地址，应该用两个类处理，再比如一个函数兼顾加减乘除，那么应该拆分成四个函数，每个函数完成单一的功能，这样组合起来也方便。

#### 开放封闭原则

实体类应该对扩展开放，对修改封闭。

比如，商店打折，如果写成一个类，一个函数if{}else if{}...这样判断处理，那么每新增一个打折方式，就得修改这个类里的函数，这是一种有风险的操作。更合适的处理，是采用策略模式，给每种折扣一个类，实现统一的接口，接口里仅打折这样一个功能，那么新增的打折方式，只要新增类即可，不用修改现有类。

#### 里氏替换原则

一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序的错误。

如果两个类有些继承关系，但不完全是，那么可以采用委派模式，也可以采用聚合关系，将A作为B的某个属性

#### 接口分离原则

客户(client)不应被强迫依赖它不使用的方法。即，一个类实现的接口中，包含了它不需要的方法。将接口拆分成更小和更具体的接口，有助于解耦，从而更容易重构、更改。

比如，商家接入移动支付API的场景举例，支付宝支持收费和退费；微信接口只支持收费。如果接口设计了收费和退费，那么微信支付就有一个空实现，而改进的话，将一个接口拆成两个接口，收费一个，退费一个。

#### 依赖倒置原则

1. 高层次的模块不应依赖低层次的模块，他们都应该依赖于抽象。
2. 抽象不应依赖于具体实现，具体实现应依赖抽象。

> **扩展**
>
> 控制反转(IOC)和依赖注入(DI)是Spring中最重要的核心概念之一，而两者实际上是一体两面的。
>
> - 依赖注入
>   - 一个类依赖另一个类的功能，那么就通过注入，如构造器、setter方法等，将这个类的实例引入。
>   - 侧重于实现。
> - 控制反转
>   - 创建实例的控制权由一个实例的代码剥离到IOC容器控制，如xml配置中。
>   - 侧重于原理。
>   - 反转了什么：原先是由类本身去创建另一个类，控制反转后变成了被动等待这个类的注入。



### 最小知识原则

最少知识原则(LKP)说的是一个软件实体应当尽可能少地与其他实体发生相互作用。

如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些请求。

> **扩展**
>
> 设计模式里，中介者和外观模式都体现了这一原则

### KISS

保持简单和单调（Keep It Simple, Stupid）,表达的是代码简单、清晰、易于理解。

KISS思想类似单一职责，复杂的问题通过拆分成多个简单易于理解的小模块处理，而不是在一个大的复杂的模块里解决，这样不利于维护，且容易有bug。

### DRY

不要重复自己（Don't Repeat Yourself），这是软件开发的一个基本原则，目的是减少信息的重复。该原理表述:“每一个知识或逻辑必须在一个系统中有一个单一的、明确的表示。”

DRY原则的一个很好的例子是企业库enterprise libraries中的helper类，其中每行代码都在库libraries和helper类中是惟一的。

### 高内聚低耦合

高内聚低耦合，是软件工程中的概念，是判断软件设计好坏的标准，主要用于程序的面向对象的设计，主要看类的内聚性是否高，耦合度是否低。 目的是使程序模块的可重用性、移植性大大增强。 通常程序结构中各模块的内聚程度越高，模块间的耦合程度就越低。

# 设计模式

### 创建型

#### Factory（工厂模式）

提供了一种创建对象的方式

**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

**主要解决：**主要解决接口选择的问题。

**何时使用：**我们明确地计划不同条件下创建不同实例时。

**如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。

**优点：** 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

> **个人评价**
>
> 基础的设计模式，复杂类的构建可以多用用。如果说某种情况下，工厂模式和建造者模式都能用，那么建议用建造者模式，更灵活点。

#### Abstract Factory（抽象工厂）

一个超级工厂创建其他工厂，创建型模式

**意图：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**主要解决：**主要解决接口选择的问题。

**何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

**如何解决：**在一个产品族里面，定义多个产品。

**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

> **个人评价**
>
> 在性能要求不高场景，可结合反射与泛型，能一定程度提高代码复用。但它有个致命的缺点，那就是扩展超级工厂里的新工厂方法时，原本的工厂类都需要新增一个该新工厂方法的空实现。

#### Builder（建造者模式）

使用多个简单的对象一步一步构建成一个复杂的对象。

**意图：**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

**主要解决：**主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

**何时使用：**一些基本部件不会变，而其组合经常变化的时候。

**如何解决：**将变与不变分离开。

**优点：** 1、建造者独立，易扩展。 2、便于控制细节风险。

**缺点：** 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。

> **个人评价**
>
> 非常常见，值得拥有，在Builder类中可以将目标类的成员属性，在Builder类中复刻一份，这样Builder类中，可以set该属性并返回Builder类，在最终build该目标类时，把属性在传给目标类。这么做的好处是，能形成链式编程，一路set到底，最后build一下，清晰。

#### Prototype（原型模式）

用于创建重复的对象，同时又能保证性能。

**意图：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**主要解决：**在运行期建立和删除原型。

**何时使用：** 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

**如何解决：**利用已有的一个原型对象，快速地生成和原型对象一样的实例。

**优点：** 1、性能提高。 2、逃避构造函数的约束。

**缺点：** 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。

>**个人评价**
>
>非常常见，但不单独使用，一般和工厂方法一起使用，原型负责创建对象，然后由工厂方法提供给调用者。省了new的过程，对于构造需要繁琐数据的对象，这个模式是个好方案。

#### Singleton（单例模式）

针对单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**主要解决：**一个全局使用的类频繁地创建与销毁。

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**优点：**

- 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
- 2、避免对资源的多重占用（比如写文件操作）。

**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

> **个人评价**
>
> 常见，给其他提供的，只会是同一个实例对象

### 结构型

#### Proxy（代理模式）

一个类代表另一个类的功能，结构型模式

**意图：**为其他对象提供一种代理以控制对这个对象的访问。

**主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

**何时使用：**想在访问一个类时做一些控制。

**如何解决：**增加中间层。

**优点：** 1、职责清晰。 2、高扩展性。 3、智能化。

**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

> **扩展**
>
> 1. **委派模式**
>
> 委派模式的基本作用就是负责任务的调度和分配任务
>
> 与代理比较：
>
> - 委派模式的基本目的就是负责任务的调用和分配，和代理模式很像，可以看成是一个特殊的静态代理的全权代理
> - 但是代理模式注重过程()，委派模式注重结果(老板不关注任务是怎么完成的，只管把任务交给经理让他去委派调度)。
> - 代理模式中，代理类的被代理对象始终不变，而委派模式中委派类的被委托对象可以随时切换。
> - 委派模式中委派类相当于全权代理，而不是像代理模式是部分代理
> - 也有人理解为代理模式中二者是上下级关系，而委派模式中二者是平级关系
>
> 2. **动态代理常用实现方式**
>    - JDK
>    - CGLIB



# 类与类之间的关系

### 关联关系

- **单向关联**

  Customer与Address的关系，每个顾客都有一个地址。UML图中带箭头的直线表示

- **双向关联**

  Customer与Product的关系，顾客可以购买多个商品，而通类商品可以被多个顾客购买。UML图中不带箭头的直线表示

- **自关联**

  自己包含自己，类似递归，UML类图中一个带有箭头且指向自身的直线表示

### 聚合关系

Car和Engine的关系，UML图中带空心菱形和箭头的直线表示，菱形指向Car

### 组合关系

Mouth和Head的关系，UML图中带实心菱形和箭头的直线表示，菱形指向Head

### 依赖关系

Driver的drive方法只有传入Car对象才能发挥作用，因此Driver类依赖于Car类。UML图中带有箭头的虚线表示，箭头指向依赖类。

### 继承关系

类继承另一个类，extend关键字，UML图中空心三角+实线

### 接口实现关系

类实现某个接口，implement关键字，UML图中空心三角+虚线

> **扩展**
>
> 组合和聚合的区别，组合中“部分”脱离“整体”便无法存在，聚合中“部分”脱离“整体”是可以存在的。



**参考**

[java进阶训练营](https://u.geekbang.org/subject/java/1000579?utm_source=u_list_web&utm_medium=u_list_web&utm_term=u_list_web)

[面向对象的SOLID原则白话篇](https://www.cnblogs.com/wuyuegb2312/p/7011708.html)

[设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)

[【设计模式】——代理、策略、委派模式还在傻傻分不清？](https://blog.csdn.net/qq_37141773/article/details/100561553)

[高内聚低耦合_百度百科](https://baike.baidu.com/item/高内聚低耦合)

